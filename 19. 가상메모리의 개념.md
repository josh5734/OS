## 0. 들어가면서
* 이제 가상메모리(Virtual Memory)에 대해 공부해보고자 한다.
* 가상 메모리는 Virtual 또는 Logical Memory라고 부르는데, 이전에 Memory Management를 공부하면서 사용했던 개념이다.

## 1. Concepts of Virtual Memory
```
- 가상 메모리는 프로세스가 가진 이미지의 주소 공간으로, 실제 물리적 메모리와는 독립적이다.
- 멀티프로세싱 환경에서 각 프로세스는 자신의 가상 메모리 공간을 갖고 있고, 이들을 Run time에 Physical Memory에 올려서 사용하는 것이다.
```
* 따라서 우리의 과제는 Process가 만들어내는 Virtual Address를 어떻게 Physical Address로 바꿀 것인가에 관한 것이다.
* 실제로 이전에 메모리 관리 기법에서 Partitioning, Buddy system, Paging, Segmentation 등을 배웠는데, 이 중에서 실제로 어떤 메모리 관리 기법을 발전시키고 사용하는지 보고자 한다.


## 2. Virtual Memory Techniques
* 가상 메모리 사용의 가장 핵심적인 목표는 "프로그래머가 Physical Address를 신경쓰지 않고, Logical Address에 대해서만 고민하게 하는 것"이다.
```
- 이를 위해 Multi-Processing 상황에서 각 프로세스의 가상 메모리는 서로 독립적이어야 하고, 하나의 프로세스가 터져도 다른 프로세스에게 영향이 가면 안 된다.
- 또한 모든 가상 메모리들이 통째로 물리적 메모리에 올려지는 것이 아니라, 공유 가능한 부분은 공유하고 / 실제 사용하는 영역만 올리려고 한다.

- 이를 통해서 우리가 이전 장의 초반 부분에서 던졌던 물음에 대해 답변할 수 있다.
- "RAM이 1GB라고 하면 32-bit architecture에서 각 PCB는 4GB이고 수 천개의 프로세스가 돌아가는데, 어떻게 이 주소들을 RAM에 올리는 것일까?
- 이 물음에 대한 답을 "모든 가상 메모리를 물리적 메모리에 올리지 않고, 필요한 부분만 + 공유 가능하면 한 번만 올리는 것"으로 대답할 수 있다.
```
* 이제 실제로 이 과정을 구현하는 방법인 **demand Paging** 개념에 대해 알아보자.
---

## 3. Demand Paging
* Demand Paging은 이름 그대로 필요한 부분의 페이지 영역만 물리적 메모리에 할당하는 것이다.
* 이전 장에서 우리는 **Swapping에 대해 배웠는데** 여기서 이 개념이 아래와 같이 살짝 바뀐다.
```
기존 Swapping: 물리적 메모리에 존재하는 프로세스 자체를 HDD 등 Storage로 뺐다가 재배치했다가 하는 과정
-> 새로운 Swapping: 물리적 메모리에 존재하는 프로세스의 "페이지" 일부를 뺐다가 재배치했다가 하는 과정
```
* 위와 같은 Swapping 개념의 변화를 통해 우리는 **한 시점에서 빈번히 쓰이는 페이지만 물리적 메모리에 담아서 사용하게 된다.**
* 아래 그림을 보자.   
![image](https://user-images.githubusercontent.com/61929745/117920656-37bc0780-b32a-11eb-918b-40d586e073d7.png)
```
* 그림을 보면 맨 왼쪽의 프로세스가 가지는 여러 개의 페이지 중에서 실제로 물리적 메모리에 올라가 있는 것은 A, C, F밖에 없다.
* 프로세스가 돌아가는 동안 MMU는 실시간으로 Page table을 확인하고, 필요한 Page가 Physical Memory에 있으면 사용하면 된다.
* 그림의 Page table을 보면 Present bit을 볼 수 있는데, 이 비트가 1인지 0인지 확인해서 물리 메모리에 해당 페이지가 저장되어 있는지 알 수 있다.
* 만약 Present bit이 0이면, 사용하려는 페이지가 물리적 메모리에 지금 없다는 뜻이 되는데, 이 때는 해당 page table의 entry에 Storage의 어느 위치에 필요한 Page가 저장되어 있는지 써 있다.
```
* 하지만 위에서 말했다시피, 필요한 페이지가 지금 물리적 메모리에 없는 상황이 필연적으로 발생한다. RAM의 무한정 크지는 않기 때문이다.
* 이 상황을 우리는 **Page Fault**라고 부르고 이것을 관리하는 이슈를 Page fault Handling이라고 한다.
---

## 4. Page fault Handling

