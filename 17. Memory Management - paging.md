## 0. 들어가면서
* 지금까지 배운 Partitioning, Buddy system 등의 메모리 관리 기법은 프로세스의 논리적인 메모리 주소를 물리적인 메인 메모리에 **연속적인 Mapping**을 전제했다.
* 하지만 지금부터 알아 볼 Paging에서는 물리적인 주소가 연속적이지 않은 상황에서도 가능하다.

---
## 1. Paging Concepts
```
1. frames: Physical memory를 fixed-size로 분할한 블록
2. pages: Logical memory를 fixed-size로 분할한 블록

- frame과 page의 size는 같게 설정하도록 한다.
- To run a program of size 'n' pages, we need to fine 'n' free frames and load program
```
* 위에 설명한 것처럼 Paging 기법은 프로세스의 논리적 메모리와 메인 메모리의 주소를 일정한 크기로 쪼개서 각각을 매칭하는 것으로 이해하면 된다.
* 당연하게도 메모리를 일정한 크기로 쪼개서 각각을 매칭하는 것이기 때문에 Internal framentaion이 존재할 수 있다.
---

## 2. pages, frames
1. page의 개념
* 프로세스의 논리적 주소 공간은 여러 개의 동일한 크기의 page들로 쪼개진다.
* 따라서 논리적 주소의 한 부분은 (# of page, offset)으로 표현이 가능하다.
2. frame의 개념
* 마찬가지로 물리적 주소 공간 역시 여러 개의 동일한 크기의 frame들로 쪼개진다.
* 따라서 물리적 주소이 한 부분 역시 (# of frame, offset)으로 표현이 가능

```
- 논리적 메모리와 물리적 메모리가 각각 page, frame으로 쪼개졌고
- 이제 우리는 아래 그림처럼 pages를 frames로 Mapping이 가능해진다.
```
![image](https://user-images.githubusercontent.com/61929745/117564825-ee30aa00-b0e8-11eb-9a29-4192d3e92d45.png)   

---

## 3. Virtual Address Translation
* page는 논리적 주소 공간을 쪼갠 것이고, frame은 물리적 메모리 공간을 쪼갠 것이다.
* 위의 그림처럼 page는 frame에 각각 매핑이 되고, 반드시 연속적으로 매핑될 필요는 없다.
* 그러면 어떻게 page들을 frame에 매핑할까?
```
- 기본적으로 모든 page는 각자가 매핑되는 frame에 대한 정보가 기록된 Page Table이 필요하다.
- 따라서 Page table은 페이지의 수만큼의 entry를 가져야한다.
```

- 이제 조금 더 매핑 과정을 구체화시켜보자.
1) 위에서 논리적 메모리 주소는 (# of page, offset)으로 표현된다고 했고, page의 크기와 frame의 크기는 같다고 했다.
2) 만약 시스템이 32KB의 물리적 주소 공간을 갖고, 각 페이지는 1024byte의 공간을 갖는다고 해보자.
3) 그러면 하나의 페이지 내에서 가질 수 있는 offset의 주소는 0부터 1023이 되고, frame 역시 같은 사이즈니까 0부터 1023만큼의 offset이 존재하겠지?
4) 아래 그림처럼 4번째 page의 offset = 0인 블록은 0번째 frame의 offset = 0에 매핑이 되고, 3번째 page의 offset = 1023인 블록은 4번째 frame의 offset = 1023에 매핑된다.   
![image](https://user-images.githubusercontent.com/61929745/117565189-e40fab00-b0ea-11eb-80b8-66bd8fb97da2.png)

5) 사실 그림의 page table을 자세히 들여다보면, 몇 번째 page가 몇 번째 frame으로 매핑되어 있느냐가 써있기는 한데, offset 정보는 안 써있다.
6) TODO: offset 정보는(?) 
---

## 4. Page Table Structure
* 프로세스 하나는 하나의 Page table을 가지고 있고, 테이블 안에는 프로세스의 모든 Page To frame Mapping 정보가 담겨있다.
* 하지만 Page table은 단순히 이 정보만 담고 있는 것이 아니고, **Bit flags** 정보를 담고 있다.
* Bit flag에는 present bit, dirty bit, reference bit, protection bit 등이 존재한다.
* 예를 들어 Dirty bit는 해당 페이지가 수정된 적 있느냐, Accessed bit은 해당 페이지가 reference 된적 있느냐, Page present bit은 page 자체가 생성되어 있느냐 등의 정보를 담는다.   
![image](https://user-images.githubusercontent.com/61929745/117565437-31d8e300-b0ec-11eb-963b-9bd6f530731c.png)

* 구체적인 flag bit에 대한 설명은 생략하고, 필요하면 찾아봐야겠다.
---

## 5. Page Sharing
* 여러 프로세스의 Page들은 똑같은 하나의 frame에 Mapping될 수 있다.
* 생각해보면 여러 프로세스마다 동일한 데이터를 쓰는데 굳이 다른 frame을 계속 할당할 필요가 없는 것이다.

---

## 6. Page Table Implementation
* 이제 실제로 Page table을 구현에 대한 논의를 하려고 한다.
* 지금까지 내용을 간단히 요약하면 Page table은 각 프로세스마다 존재하고, 프로세스가 가지고 있는 Page 수만큼의 entry를 가진다. 그리고 각 entry는 mapping되는 frame에 대한 정보와 flag bit를 갖고 있다.
* Page table 구현을 위해 필요한 두 가지 개념에 대해 일단 알아보자.
```
1. Page-table base Register(PTBR): Points to the page table
2. Page-table length Register(PTLR): indicates size of the page table
```
* 일단 우리는 Physical memory에 저장된 정보를 읽기 위해 두 번의 Memory Access를 필요로 한다.
```
1) Page Table에 Access하여 Mapping 된 frame의 정보 얻기
2) 실제 Memory에 접근해서 data/instruction 읽기
```
* 위와 같은 과정에서는 두번의 메모리 접근 때문에 **Memory Access Overhead**가 발생하는데, 이를 해결하기 위해 Associative Memory인 **TLB(Translation Look-aside Buffer)** 를 이용한다. 참고로 일반 메모리는 주소에 접근해서 record를 반환하는 반면, Associative memory는 index가 존재하고 그에 매치되는 record를 통해 한 번 검사했던 레코드는 다음번 접근 시 바로 반환할 수 있게 해준다. 
* **따라서 우리는 아래 그림처럼 TLB를 통해서 Page table에 접근하지 않고 frame의 위치를 가져오는 식으로 속도를 줄여보겠다는 것이다.**   
![image](https://user-images.githubusercontent.com/61929745/117565828-559d2880-b0ee-11eb-8341-3534839013b6.png)   

* 그런데 위처럼 TLB를 사용해서 frame 정보를 빨리 알아보려고 했는데 TLB 테이블에 아직 frame number가 없으면 다시 Page table을 찾아가서 frame number를 얻고, 이 녀석을 TLB에 저장해주도록 한다. TLB는 약간 Cache 느낌으로 쓴다고 생각하면 될 것 같다.
```
* 정리하면 우리는 어쨌든 Page table에 매번 직접 가서 frame number를 얻고, 실제 메모리에 접근해서 읽는 것보다는 TLB에 가서 frame number를 빨리 얻고 실제 메모리에 접근하는게 좋다는 것이다. 
```
* 이 부분에서 **Hit Ratio**와 **Effective Access Time(EAT)** 라는 개념이 있다.
```
- Hit Ratio : Percentage of times that a page number is found in TLB = r
- Effective Access Time(EAT) = (1 + X) * r + (2 + X)(1 - r) = 2 + X - r
```
* EAT에서 r은 Hit ratio를 의미하고 X는 아주 짧은 시간으로 TLB에 접근하는 시간을 의미한다.
* EAT를 최소로 만드려면 r = 1로 만들어야 하는데 이는 Hit ratio = 1을 의미하고, TLB 테이블에 거의 모든 page와 frame의 매핑 정보가 있다는 뜻이다.
* 사실 이렇게 하면 EAT는 작아져서 효율은 좋아지지만 모든 내용이 TLB에 있으려면 Associative Register가 비싸기 때문에 비용적 문제가 생기는 단점이 있다.
```
- 아무튼 이런 식으로 TLB를 이용해서 CPU 메모리에 접근하는게 효율적인 Memory Aceess라는 것이고
- 한편, TLB를 이용한 Hit ratio를 높이기 위해서는 TLB에 최대한 많은 page, frame mapping 정보가 있어야 되는데 비용적 문제도 고려해야 한다는 것이다. 
```
---

## 7. Handling Large Page Table


