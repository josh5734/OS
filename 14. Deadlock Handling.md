## 0. 들어가면서
* 지난 시간에 데드락이 무엇이며, 데드락은 어떤 상황에서 발생할 수 있는지에 대한 필요조건에 대해 공부했다.
* 데드락 문제는 프로그램의 교착을 일으켜서 Process가 진행되지 않게 되고 시간과 메모리의 비효율을 초래한다.
* 따라서, 이전에 정리했던 데드락의 발생 상황을 역으로 없애줌으로써 데드락을 방지할 수 있겠다.

## 1. Deadlock Prevention or Avoidance
* Deadlock Prevention은 "데드락이 절대 발생하지 않도록 하겠다"는 것이고, Avoidance는 "데드락을 방지해보겠다"라는 의미의 차이가 있다.
* **Safe State**라는 용어를 가지고 Deadlock prevention, avoidance의 예시를 보기 위해 이 용어를 우선 정의하고자 한다.
```
- System is in safe state if there exists a safe sequence of all processes
```

### 1) Deadlock Prevention
* key Idea: **Deadlock 발생의 필요조건 4가지(Mutual Exclusion, Hold and wait, No preemption, Circular wait) 중 하나를 False로 만들겠다.**
    * Mutual Exclusion은 non-sharable한 resource에 대해서는 우리가 할 수 있는게 없다. Resource 자체에 Specific한 조건이기 때문이다.
    * Hold and Wait에 대해서는 Process가 resource를 요청할 때, 다른 어떤 resource도 들고 있지 않도록 하는 것이다. 다시 말해서, 딱 필요한 시점에 실행 가능한 resource가 있으면 그 때 바로 전부 할당받아서 No wait를 하게 해주는 것이고, 그렇지 않을 때는 자원을 내가 들고 있지 않음으로써 No hold를 하게 해준다는 것이다.
    * No preemption은 Wait해도 못 받는 상황에서는 Hold하고 있는 자원을 release하고 RollBack하겠다는 것이다. 딱 필요한 resource가 사용가능할 때만 이전에 release했던 자원과 request 가능한 자원을 받아서 실행하도록 한다. 이러한 방법은 Process가 쉽게 저장되고 다시 restore하기 편한 것들(CPU registor, memory ..)에 가능하다.
    * Circular Wait는 순서를 만들어서 Circular한 상황이 안생기도록 한다는 것이다.

### 2) Deadlock Avoidance
* Key Idea: **어떤 Process가 어떤 Resource를 요청하는지 계속 관찰하면서 Resource를 할당했을 때 Deadlock이 발생할 것 같으면 안 주겠다는 Run-time Checking**
* Run-time Checking을 위해서는 **Priori information**이 필요한데, Process가 OS에게 얼만큼의 resource가 필요하다는 정보를 미리 알려줘야 한다는 것이다.
* 이 방법은 "Resource-Allocation State"를 지속적으로 보면서 Circular-wait condition이 발생하지 않도록 한다.
* Deadlock Avoidance를 위한 **Banker's Algorithm'에 대해 살펴보자.
```
// Banker's Algorithm
1. Let Work and Finish be vectors of length m and n, respectively.
Initailize:
    Work := Available
    Finish[i] = false for i = 1,2,3,..,n

2. Find i such that both:
    (a) Finish[i] = false
    (b) Need_i <= Work
    if no such i exists, go to step 4

3. Work := Work + Allocation[i]
   Finish[i] := true
   go to step 2
   
4. If finish[i] = true for all i, then the system is in a safe state
```
* 위의 알고리즘을 실제 예시를 통해 살펴보면 아래와 같다.   


![image](https://user-images.githubusercontent.com/61929745/116347713-ad52ae80-a827-11eb-9a40-9bf956925814.png)   

* Need = Max - Allocation 값으로 계산하고, Max는 Process가 Execute되기 위해 필요한 Resource의 양이다.
* 위의 예시에서는 P1의 Need값이 Available한 Resource보다 작기 때문에 P1이 실행될 수 있고, 실행이 완료되면 사용한 자원을 release하기 때문에 Available한 Resource가 증가한다.
* 그렇게 되면 다음에 P3의 Need값보다 Available값이 커지게 되고 P3를 실행할 수 있다. 
* 이 과정을 반복하게 되면 <P1, P3, P4, P2, P0>의 순서로 safety criteria를 만족시킬 수 있다.

* 그런데 만약 P1이 (1, 0, 2)만큼 추가적인 Request가 있다면 어떨까?
* 그렇다면 현재 Allocation 값을 [3, 0, 2]로 증가시키고 Available한 양을 [1, 0, 2]만큼 감소시켜준다. 그 후에 다시 Need 값과 Available 값을 비교하면서 위처럼 풀어보면 된다.
* 위의 과정을 다시 해보면, <P1, P3, P4, P0, P2>의 순서대로 실행했을 때 Safety criteria를 만족시킬 수 있다.
* 하지만 만약 P0에게 (0, 2, 0)만큼의 request가 추가적으로 생기게 되면 어떻게 될까? safety criteria를 만족하지 못한다. 직접 종이에 해보자.

---
## 2. Deadlock Detection and Recovery
* 사실 위에서 고안한 Prevention, Avoidance는 **오버헤드도 크고 priori information을 OS에게 제공하는게 현실적으로 쉽지 않다는 제약조건**이 있다.
### 1) Detection
* 이 방법은 System이 그냥 돌아가게 둔 다음에 데드락이 발생하면 그걸 발견하고 해결한다는 것이다.
* 따라서 이 방법은 Priori information도 필요없고 그냥 되는지 안되는지 해보는 것이다.   
![image](https://user-images.githubusercontent.com/61929745/116348815-bcd2f700-a829-11eb-9c38-abfdaf1d2aea.png)

* 위 예시를 보면 Request는 현재 Allocation에서 더 필요한 Resource를 의미한다. Request값이 Available값보다 작은 Process를 먼저 실행하고 실행이 끝나면 자원을 release하는 방식으로 Safe criteria를 만족시킬 수 있는지 확인해본다.
* 그러면 <P0, P2, P3, P1, P4> 순서대로 했을 때 가능하다는 것을 알 수 있다.
---

![image](https://user-images.githubusercontent.com/61929745/116348953-f572d080-a829-11eb-8340-548cd988dacd.png)

* 하지만 위의 상황처럼 P2가 Type C resource를 하나 더 request하게 되면 어떨까?
* 지금 당장 실행 가능한 Process는 P0밖에 없는데 P0가 끝나고 자원을 release해도 다른 프로세스의 Request값이 모두 Available보다 크게 되고 Deadlock이 발생한다.

---
### 2) Recovery
* Deadlock이 발생했으면 이제 Recovery를 해야한다.
* Recovery를 하는 방법은 간단하다. **Process를 죽이거나 Resource를 Preemptive하게 쓰거나**
* 하지만 모든 프로세스를 죽일 것인가? 아니면 어떤 프로세스를 어떤 기준으로 죽일 것인가?에 대한 물음에 단편적으로 답변하기는 어렵다.
* Resource를 Preemptive하게 쓰는 것도 어떤 자원을 그렇게 사용할 것인가, 어떤 프로세스의 자원을 뺐어올 것인가, Rollback을 하게 되면 어떻게 상태를 저장하고 Recover할 것인가? 계속 같은 프로세스의 자원을 preemptive하게 뺐어버리면 startvation 문제는 생기지 않는가? 등 여러가지 물음이 남아있다.

---
## 3. 나가면서
* 지금까지 Deadlock의 개념과 발생 시점, 어떻게 해결할 것인가 등에 대한 이슈를 살펴보았다.
* 그러나 교수님의 말씀을 빌리자면, General Purpose를 가지고 있는 OS는 데드락 문제를 크게 신경쓰지 않는다고 하셨다.
* 데드락이 실제로 많은 상황에서 일어나는 일반적인 케이스도 아니며, 데드락을 해결하기 위해서 들이는 노력이 상당히 복잡하고 크기 때문이다.
* 따라서 그냥 데드락이 의심되거나 데드락이 발생한 상황에서는 "컴퓨터를 껐다 키라고 하셨다."
